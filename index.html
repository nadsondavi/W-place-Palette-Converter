<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>W/place Palette Converter</title>
<style>
  :root{
    --bg:#0f1720; --card:#0b1220; --muted:#9aa4b2; --accent:#16a34a;
    --glass: rgba(255,255,255,0.04);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body{
    margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg,#071025 0%, #071727 100%);
    color:#e6eef6; padding:24px;
  }
  .app{
    width:100%; max-width:980px; background:var(--card); border-radius:12px; padding:18px;
    box-shadow:0 6px 30px rgba(0,0,0,0.6);
  }
  header{display:flex; gap:12px; align-items:center; margin-bottom:12px;}
  h1{font-size:20px; margin:0;}
  p.lead{margin:0;color:var(--muted); font-size:13px;}

  .row{display:flex; gap:14px; align-items:flex-start;}
  .col{flex:1;}
  .controls{
    background:var(--glass); padding:12px; border-radius:8px;
    display:flex; flex-direction:column; gap:10px;
  }
  label{font-size:13px; color:var(--muted); display:block; margin-bottom:6px;}
  input[type="file"]{color:transparent;}
  .inline{display:flex; gap:8px; align-items:center;}
  .btn{
    background:#0ea5a4; color:#042022; border:none; padding:8px 12px; border-radius:8px; cursor:pointer;
  }
  .btn.secondary{background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04);}
  .small{font-size:13px; padding:6px 10px;}
  .preview{
    background:linear-gradient(45deg,#071827,#07142a); border-radius:8px; padding:12px; display:flex; gap:12px;
    align-items:center; justify-content:center; min-height:360px;
  }
  canvas{image-rendering:pixelated; max-width:100%; height:auto; border-radius:6px; background: #081426;}
  .inputs{display:flex; gap:8px; align-items:center;}
  input[type="number"]{width:110px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit;}
  .palette{display:flex; flex-wrap:wrap; gap:6px; padding-top:6px;}
  .sw{width:28px; height:28px; border-radius:4px; border:1px solid rgba(0,0,0,0.25); box-shadow: inset 0 -1px 0 rgba(0,0,0,0.12);}
  footer{margin-top:12px; display:flex; gap:8px; align-items:center; justify-content:space-between;}
  .muted{color:var(--muted); font-size:13px;}
  .kbd{background:#0b1220; border:1px solid rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; font-size:13px;}
  @media(max-width:800px){ .row{flex-direction:column;} .preview{min-height:260px;} }
</style>
</head>
<body>


  
  <div class="app">
    <header>
      <div>
        <h1>W/place Palette Converter</h1>
        <p class="lead">Converta qualquer imagem para PNG usando só as cores do W/place.</p>
      </div>
    </header>

    <div class="row">
      <div class="col controls" style="max-width:360px;">
        <label>1) Selecione imagem</label>
        <input id="file" type="file" accept="image/*">

        <label>2) Redimensionar (px)</label>
        <div class="inputs">
          <input id="width" type="number" min="1" value="500" />
          <span class="muted">×</span>
          <input id="height" type="number" min="1" value="500" />
        </div>
        <div class="inline">
          <input id="proportional" type="checkbox" checked />
          <label style="margin:0;">Manter proporção</label>
        </div>

        <label>3) Opções</label>
        <div class="inline">
          <button id="resizeBtn" class="btn small">Aplicar redimensionamento</button>
          <button id="convertBtn" class="btn small">Converter para paleta</button>
          <button id="downloadBtn" class="btn small" style="display:none">Baixar PNG</button>
        </div>

        <label>Paleta (cores do W/place)</label>
        <div id="palette" class="palette" title="Paleta usada para quantização"></div>

        <div style="margin-top:8px;">
          <label class="muted">Preservar transparência:</label>
          <div class="inline">
            <input id="preserveAlpha" type="checkbox" checked />
            <span class="muted">se marcada, pixels quase transparentes ficam transparentes</span>
          </div>
        </div>

        <div style="margin-top:8px;">
          <label class="muted">Tolerância (0-100):</label>
          <input id="tolerance" type="range" min="0" max="100" value="0" />
          <div class="muted" id="tolVal">0</div>
        </div>

      </div>

      <div class="col">
        <div class="preview">
          <canvas id="canvas" width="500" height="500"></canvas>
        </div>
      </div>
    </div>

    <footer>
      <div class="muted">Feito para W/place — clique em "Converter para paleta" e depois em "Baixar PNG".</div>
      <div class="muted">Observação: imagens muito grandes podem demorar.</div>
      <div class="muted">Me segue no instaram! @nadsonpa</div>
    </footer>
  </div>

<script>
(() => {
  // Paleta fornecida (hex) - formato: array de strings sem '#'
  const PALETTE_HEX = [
    "000000","3C3C3C","787878","D2D2D2","FFFFFF","600018","ED1C24","FF7F27","F6AA09","F9DD3B",
    "FFFABC","0EB968","13E67B","87FF5E","0C816E","10AEA6","13E1BE","60F7F2","28509E","4093E4",
    "6B50F6","99B1FB","780C99","AA38B9","E09FF9","CB007A","EC1F80","F38DA9","684634","95682A","F8B277"
  ];

  // Convert hex to rgb arrays
  const palette = PALETTE_HEX.map(h => {
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return {hex: '#' + h.toUpperCase(), r,g,b};
  });

  // UI elements
  const fileEl = document.getElementById('file');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const widthEl = document.getElementById('width');
  const heightEl = document.getElementById('height');
  const proportional = document.getElementById('proportional');
  const resizeBtn = document.getElementById('resizeBtn');
  const convertBtn = document.getElementById('convertBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const paletteDiv = document.getElementById('palette');
  const preserveAlpha = document.getElementById('preserveAlpha');
  const toleranceRange = document.getElementById('tolerance');
  const tolVal = document.getElementById('tolVal');

  // fill palette in UI
  palette.forEach(c => {
    const sw = document.createElement('div');
    sw.className = 'sw';
    sw.style.background = c.hex;
    sw.title = c.hex;
    paletteDiv.appendChild(sw);
  });

  tolVal.textContent = toleranceRange.value;
  toleranceRange.addEventListener('input', () => tolVal.textContent = toleranceRange.value);

  let originalImg = null;
  let naturalW = 0, naturalH = 0;

  fileEl.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        originalImg = img;
        naturalW = img.naturalWidth;
        naturalH = img.naturalHeight;
        // set default size to original or fit
        const fitW = Math.min(800, naturalW);
        const fitH = Math.round(fitW * naturalH / naturalW);
        widthEl.value = fitW;
        heightEl.value = fitH;
        drawToCanvas(img, parseInt(widthEl.value), parseInt(heightEl.value));
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(f);
  });

  // maintain proportion
  widthEl.addEventListener('input', () => {
    if (!originalImg) return;
    if (proportional.checked) {
      const w = parseInt(widthEl.value) || 1;
      const h = Math.max(1, Math.round(w * naturalH / naturalW));
      heightEl.value = h;
    }
    drawToCanvas(originalImg, parseInt(widthEl.value), parseInt(heightEl.value));
  });
  heightEl.addEventListener('input', () => {
    if (!originalImg) return;
    if (proportional.checked) {
      const h = parseInt(heightEl.value) || 1;
      const w = Math.max(1, Math.round(h * naturalW / naturalH));
      widthEl.value = w;
    }
    drawToCanvas(originalImg, parseInt(widthEl.value), parseInt(heightEl.value));
  });

  proportional.addEventListener('change', () => {
    if (!originalImg) return;
    if (proportional.checked) {
      // sync height to width
      const w = parseInt(widthEl.value) || 1;
      heightEl.value = Math.max(1, Math.round(w * naturalH / naturalW));
      drawToCanvas(originalImg, parseInt(widthEl.value), parseInt(heightEl.value));
    }
  });

  resizeBtn.addEventListener('click', () => {
    if (!originalImg) return alert('Selecione uma imagem primeiro');
    drawToCanvas(originalImg, parseInt(widthEl.value), parseInt(heightEl.value));
  });

  // draw image to canvas (keeps image data)
  function drawToCanvas(img, w, h) {
    canvas.width = Math.max(1, w);
    canvas.height = Math.max(1, h);
    // clear
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // draw with smoothing disabled for pixel clarity if reduced
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    // show download hidden until conversion
    downloadBtn.style.display = 'none';
  }

  // quantize pixel to nearest palette color (euclidean)
  function findNearestColor(r,g,b) {
    let best = null;
    let bestDist = Infinity;
    for (let i=0;i<palette.length;i++){
      const p = palette[i];
      const dr = r - p.r;
      const dg = g - p.g;
      const db = b - p.b;
      const d = dr*dr + dg*dg + db*db;
      if (d < bestDist){ bestDist = d; best = p; }
    }
    return best;
  }

  // main conversion
  convertBtn.addEventListener('click', async () => {
    if (!originalImg) return alert('Selecione uma imagem primeiro');
    // ensure canvas has desired size
    const w = canvas.width, h = canvas.height;
    // get image data
    const imageData = ctx.getImageData(0,0,w,h);
    const data = imageData.data;
    const preserve = preserveAlpha.checked;
    const tol = parseInt(toleranceRange.value,10) || 0;

    // Optionally define: if pixel nearly transparent keep transparent
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
      if (a === 0) continue; // fully transparent stays transparent
      if (preserve && a < 30) { // very transparent -> keep transparent
        data[i+3] = 0;
        continue;
      }

      // If tolerance > 0 and palette contains a color within tolerance (euclidean), snap to it,
      // else map to nearest color (this avoids replacing nearly-equal colors when user wants).
      const nearest = findNearestColor(r,g,b);
      if (tol > 0) {
        // compute euclidean distance (sqrt not necessary)
        const dr = r - nearest.r;
        const dg = g - nearest.g;
        const db = b - nearest.b;
        const dist = Math.sqrt(dr*dr + dg*dg + db*db);
        if (dist <= tol) {
          // use nearest palette color
          data[i] = nearest.r; data[i+1] = nearest.g; data[i+2] = nearest.b; data[i+3] = 255;
        } else {
          // still use nearest (we always map), but this branch kept for clarity
          data[i] = nearest.r; data[i+1] = nearest.g; data[i+2] = nearest.b; data[i+3] = 255;
        }
      } else {
        data[i] = nearest.r; data[i+1] = nearest.g; data[i+2] = nearest.b; data[i+3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    // update download button
    downloadBtn.style.display = 'inline-block';
    downloadBtn.onclick = async () => {
      // convert to blob and download
      // to preserve transparency convert with toBlob
      canvas.toBlob((blob) => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'wplace-converted.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);
      }, 'image/png');
    };
  });

})();
</script>
</body>
</html>
